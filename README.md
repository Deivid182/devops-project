# DevOps Project - Authentication API

A production-ready Node.js/Express authentication microservice with PostgreSQL, built using clean architecture principles and modern JavaScript patterns.

## Table of Contents

- [Overview](#overview)
- [Architecture](#architecture)
- [Key Components](#key-components)
- [Data Flow](#data-flow)
- [Tech Stack](#tech-stack)
- [Getting Started](#getting-started)
- [API Endpoints](#api-endpoints)
- [Development](#development)
- [Project Structure](#project-structure)

## Overview

**Project Type**: RESTful API Backend Service  
**Purpose**: This is a Node.js/Express authentication microservice that provides user registration and management capabilities. It's designed as the backend foundation for a larger application that needs secure user authentication with JWT tokens.

## Architecture

The project follows a **Layered Architecture** pattern with clear separation of concerns:

```
┌─────────────────────────────────────────────┐
│                 HTTP Layer                   │
│        (Express Routes + Middleware)        │
├─────────────────────────────────────────────┤
│              Controller Layer                │
│         (Request/Response Handling)          │
├─────────────────────────────────────────────┤
│               Service Layer                  │
│            (Business Logic)                  │
├─────────────────────────────────────────────┤
│                Data Layer                    │
│         (Drizzle ORM + PostgreSQL)          │
└─────────────────────────────────────────────┘
```

### Module Organization

The codebase is organized into focused modules:
- **`src/routes/`** - API endpoint definitions
- **`src/controllers/`** - HTTP request/response handlers
- **`src/services/`** - Core business logic
- **`src/models/`** - Database schema definitions
- **`src/middleware/`** - Cross-cutting concerns (validation, error handling)
- **`src/utils/`** - Reusable utility functions
- **`src/config/`** - Application configuration
- **`src/validations/`** - Input validation schemas
- **`src/exceptions/`** - Custom error classes

## Key Components

### Authentication System
- **Purpose**: Complete user registration and JWT-based authentication
- **Components**: 
  - `AuthController` - handles HTTP requests
  - `AuthService` - contains business logic (user creation, password hashing)
  - `registerSchema` - Zod validation for user input
  - JWT utilities for token generation

### Database Layer
- **ORM**: Drizzle ORM with PostgreSQL
- **Provider**: Neon Serverless PostgreSQL
- **Schema**: Single `users` table with id, name, email, password, role, timestamps
- **Migration System**: SQL files generated by Drizzle Kit

### Error Handling System
- **Custom Exceptions**: `ConflictException`, `BadRequestException`, etc.
- **Global Middleware**: Catches and formats all errors consistently
- **Validation Integration**: Zod errors are automatically formatted and returned

### Security Layer
- **Password Hashing**: bcrypt with salt rounds
- **JWT Tokens**: Stored as HTTP-only cookies
- **Input Validation**: Zod schemas prevent malicious input
- **Security Headers**: Helmet middleware for protection

## Data Flow

Here's how a typical user registration request flows through the system:

```
┌─────────────┐    ┌──────────────┐    ┌─────────────────┐    ┌──────────────┐
│   Client    │───▶│    Routes    │───▶│   Controller    │───▶│   Service    │
│ POST /auth/ │    │ auth.routes  │    │ auth.controller │    │ auth.service │
│  register   │    │              │    │                 │    │              │
└─────────────┘    └──────────────┘    └─────────────────┘    └──────────────┘
                                                │                       │
                                                ▼                       ▼
┌─────────────┐    ┌──────────────┐    ┌─────────────────┐    ┌──────────────┐
│  Response   │◄───│   Cookie +   │◄───│   Validation    │◄───│  Database    │
│ {user info} │    │  JWT Token   │    │  (Zod Schema)   │    │ (PostgreSQL) │
│             │    │              │    │                 │    │              │
└─────────────┘    └──────────────┘    └─────────────────┘    └──────────────┘
```

### Step-by-step Execution

1. **Route Handler** (`/api/auth/register`) receives POST request
2. **Controller** extracts request body and calls validation middleware
3. **Validation Middleware** uses Zod schema to validate input data
4. **Service Layer** checks if user exists, hashes password, creates user record
5. **Database Layer** (Drizzle ORM) executes SQL INSERT and returns user data
6. **JWT Utility** generates signed token with user payload
7. **Cookie Utility** sets HTTP-only cookie with JWT token
8. **Response** returns user info (excluding password) with 201 status

## Tech Stack

### Core Framework
- **Express.js 5.x** - Web framework with modern async support
- **Node.js ESM** - Uses ES modules throughout

### Database Stack
- **PostgreSQL** - Primary database
- **Neon Serverless** - Cloud PostgreSQL provider
- **Drizzle ORM** - Type-safe ORM with excellent developer experience
- **Drizzle Kit** - Migration and studio tools

### Security & Authentication
- **bcrypt** - Password hashing with salt
- **jsonwebtoken** - JWT token generation/verification
- **helmet** - Security headers middleware
- **CORS** - Cross-origin resource sharing

### Validation & Error Handling
- **Zod** - Runtime type validation and parsing
- **Custom Exception Classes** - Structured error handling

### Logging & Development
- **Winston** - Production-grade logging
- **Morgan** - HTTP request logging middleware
- **ESLint + Prettier** - Code quality and formatting

## Getting Started

### Prerequisites
- Docker and Docker Compose installed
- Node.js 18+ (for local development without Docker)
- Neon Database account with a project set up
- npm or yarn

### Quick Start with Docker (Recommended)

#### Development Environment

1. Clone the repository:
```bash
git clone <repository-url>
cd devops-project
```

2. Set up Neon Local environment:
```bash
cp .env.development .env.development.local
# Edit .env.development.local with your Neon credentials:
# - NEON_API_KEY: Your Neon API key
# - NEON_PROJECT_ID: Your Neon project ID
# - PARENT_BRANCH_ID: The branch ID to create ephemeral branches from
```

3. Start development environment with Docker:
```bash
# Load your development environment variables
export $(grep -v '^#' .env.development.local | xargs)

# Start development environment
docker-compose -f docker-compose.dev.yml up --build
```

This creates:
- Neon Local proxy with ephemeral database branches
- Node.js app with hot reloading on port 3000
- Automatic database branch cleanup when containers stop

#### Production Environment

1. Set up production environment variables:
```bash
# Update .env.production with your actual Neon Cloud connection string
export DATABASE_URL="postgres://username:password@ep-example.neon.tech/dbname?sslmode=require"
export JWT_SECRET="your-production-jwt-secret"
```

2. Deploy production environment:
```bash
docker-compose -f docker-compose.prod.yml up --build -d
```

### Local Development (Without Docker)

1. Install dependencies:
```bash
npm install
```

2. Set up environment variables:
```bash
cp .env.development .env
# Edit .env with your Neon database credentials
```

3. Start Neon Local proxy:
```bash
docker run --name neon-local -p 5432:5432 \
  -e NEON_API_KEY=${NEON_API_KEY} \
  -e NEON_PROJECT_ID=${NEON_PROJECT_ID} \
  -e PARENT_BRANCH_ID=${PARENT_BRANCH_ID} \
  neondatabase/neon_local:latest
```

4. Run database migrations:
```bash
npm run db:migrate
```

5. Start the development server:
```bash
npm run dev
```

The server will start on `http://localhost:3000`

## API Endpoints

### Health Check
- `GET /health` - Server health status
- `GET /` - Basic server response
- `GET /api` - API status check

### Authentication
- `POST /api/auth/register` - Register a new user

#### Register User
```http
POST /api/auth/register
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com",
  "password": "mypassword123",
  "role": "user" // optional, defaults to "user"
}
```

**Response:**
```json
{
  "message": "User registered successfully",
  "user": {
    "id": 1,
    "name": "John Doe",
    "email": "john@example.com",
    "role": "user"
  }
}
```

## Development

### Available Commands

```bash
# Start development server with file watching
npm run dev

# Database operations
npm run db:generate   # Generate Drizzle migrations
npm run db:migrate    # Run database migrations
npm run db:studio     # Open Drizzle Studio (database GUI)

# Code quality
npm run lint          # Run ESLint
npm run lint:fix      # Fix ESLint issues automatically
npm run format        # Format code with Prettier
npm run format:check  # Check code formatting

# Docker operations
docker-compose -f docker-compose.dev.yml up --build     # Start development environment
docker-compose -f docker-compose.prod.yml up --build -d # Start production environment
docker-compose -f docker-compose.dev.yml logs -f app    # Follow application logs
docker-compose -f docker-compose.dev.yml exec app bash  # Access container shell
```

### Database Operations

#### Development (with Neon Local)
```bash
# Run migrations on development
docker-compose -f docker-compose.dev.yml exec app npm run db:migrate

# Access Drizzle Studio (database GUI)
docker-compose -f docker-compose.dev.yml exec app npm run db:studio

# Generate new migrations
docker-compose -f docker-compose.dev.yml exec app npm run db:generate
```

#### Production (with Neon Cloud)
```bash
# Run migrations on production
docker-compose -f docker-compose.prod.yml exec app npm run db:migrate
```

### Path Imports System

The project uses Node.js import maps for clean imports:
- `#config/*` → `./src/config/*.js`
- `#models/*` → `./src/models/*.js`
- `#utils/*` → `./src/utils/*.js`
- `#controllers/*` → `./src/controllers/*.js`
- `#routes/*` → `./src/routes/*.js`
- `#services/*` → `./src/services/*.js`
- `#middleware/*` → `./src/middleware/*.js`
- `#validations/*` → `./src/validations/*.js`
- `#exceptions/*` → `./src/exceptions/*.js`
- `#common/*` → `./src/common/*.js`

### Testing API Endpoints

Use the included `api.http` file with REST Client extensions in your IDE:

```http
@local_base_url = http://localhost:3000/api

POST {{local_base_url}}/auth/register
Content-Type: application/json

{
  "name": "David Peralta Mendoza",
  "email": "dave@davecoder.com",
  "password": "Test123@"
}
```

## Project Structure

```
devops-project/
├── Dockerfile               # Multi-stage Docker build
├── .dockerignore           # Docker build optimization
├── docker-compose.dev.yml  # Development with Neon Local
├── docker-compose.prod.yml # Production with Neon Cloud
├── .env.development        # Development environment template
├── .env.production         # Production environment template
├── drizzle/                # Database migrations
│   ├── 0000_*.sql         # Migration files
│   └── meta/              # Migration metadata
├── logs/                   # Application logs
├── src/
│   ├── app.js              # Express app configuration
│   ├── index.js            # Application entry point
│   ├── server.js           # Server startup
│   ├── common/             # Shared constants
│   │   └── http-status/    # HTTP status codes
│   ├── config/             # Configuration files
│   │   ├── database.js     # Database connection
│   │   └── logger.js       # Winston logger setup
│   ├── controllers/        # Route handlers
│   ├── exceptions/         # Custom error classes
│   ├── middleware/         # Express middleware
│   ├── models/             # Database schema (Drizzle)
│   ├── routes/             # API route definitions
│   ├── services/           # Business logic layer
│   ├── utils/              # Utility functions
│   └── validations/        # Input validation schemas
├── api.http                # API testing file
├── drizzle.config.js       # Drizzle ORM configuration
├── eslint.config.js        # ESLint configuration
├── jsconfig.json           # JavaScript project configuration
└── package.json            # Project dependencies and scripts
```

## Docker Environment Configuration

### Development Environment
- **Neon Local**: Creates ephemeral branches automatically for each container restart
- **Database URL**: `postgres://user:password@neon-local:5432/main`
- **Hot Reloading**: Enabled via volume mounts for real-time code changes
- **Debug Mode**: Full logging and development tools available
- **Isolation**: Each development session gets a fresh database branch

### Production Environment
- **Neon Cloud**: Direct connection to production Neon database
- **Database URL**: Actual Neon connection string with SSL
- **Security**: Read-only filesystem, non-root user, resource limits
- **Health Checks**: Automatic container health monitoring
- **Scalability**: Optimized for production deployment with proper resource management

### Multi-Stage Dockerfile Benefits
- **Development Stage**: Includes all dev dependencies and debugging tools
- **Production Stage**: Minimal image with only runtime dependencies
- **Security**: Non-root user, read-only filesystem in production
- **Optimization**: Separate dependency layer for better Docker caching

## Strengths & Trade-offs

### Strengths
- **Clean Architecture**: Clear separation of concerns makes the code maintainable
- **Type Safety**: Zod validation + TypeScript JSDoc provides good type coverage
- **Security First**: HTTP-only cookies, password hashing, input validation, security headers
- **Modern Stack**: Uses latest Node.js features (ES modules, import maps)
- **Developer Experience**: Hot reload, structured logging, database studio tools
- **Scalable Foundation**: Layered design allows easy feature additions

### Current Limitations
- **Single User Entity**: Currently only supports basic user model
- **No Authentication Middleware**: Missing JWT verification middleware for protected routes
- **Limited Session Management**: JWT tokens have fixed expiration, no refresh token mechanism
- **Testing Gap**: No test suite implemented yet

## Contributing

This project follows clean architecture principles and modern JavaScript patterns. When contributing:

1. Follow the existing layered architecture
2. Use the established import map aliases
3. Add appropriate validation schemas for new endpoints
4. Include proper error handling with custom exceptions
5. Update this README for any architectural changes

## License

ISC License

---

**This authentication microservice provides a solid foundation that can be extended with additional features like login endpoints, protected routes, user profiles, and role-based authorization.**